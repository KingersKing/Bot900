-- Auto Rejoin + Reattach (client-side LocalScript)
-- Set this to the loader URL you want re-executed after teleport.
local loader_url = "https://example.com/your_loader.lua"

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local REJOIN_INTERVAL = 3600 -- seconds (1 hour)
local COUNTDOWN_SECONDS = 10 -- optional countdown before teleport (set 0 to disable)

-- Builds the payload that will run on the next join
local function buildPayload(url)
    -- This payload tries to fetch the loader and execute it using either syn.request or game:HttpGet
    -- It uses pcall to avoid hard errors if HTTP isn't available.
    local payload = ([[
        local url = %q
        local function httpGet(u)
            -- Try syn.request style first
            if type(syn) == "table" and type(syn.request) == "function" then
                local ok, r = pcall(syn.request, {Url = u, Method = "GET"})
                if ok and r and r.Body then return r.Body end
            end
            -- Fallback to http_get / httpget style names commonly provided by executors
            if type(http_request) == "function" then
                local ok, r = pcall(http_request, {Url = u, Method = "GET"})
                if ok and r and r.Body then return r.Body end
            end
            if type(httpget) == "function" then
                local ok, r = pcall(httpget, u)
                if ok then return r end
            end
            if type(game.HttpGet) == "function" then
                local ok, r = pcall(function() return game:HttpGet(u) end)
                if ok then return r end
            end
            return nil
        end

        pcall(function()
            local body = httpGet(url)
            if body then
                -- prefer loadstring then load
                local f, err = loadstring and loadstring(body) or load(body)
                if f then
                    pcall(f)
                end
            end
        end)
    ]]):format(url)
    return payload
end

-- Try to queue the payload using known queue_on_teleport API names
local function tryQueueOnTeleport(code)
    local ok, err

    -- syn executor
    ok, err = pcall(function()
        if type(syn) == "table" and type(syn.queue_on_teleport) == "function" then
            syn.queue_on_teleport(code)
            return true
        end
    end)
    if ok and err == true then return true end

    -- generic queue_on_teleport
    ok, err = pcall(function()
        if type(queue_on_teleport) == "function" then
            queue_on_teleport(code)
            return true
        end
    end)
    if ok and err == true then return true end

    -- another common alias some executors expose
    ok, err = pcall(function()
        if type(shared) == "table" and type(shared.queue_on_teleport) == "function" then
            shared.queue_on_teleport(code)
            return true
        end
    end)
    if ok and err == true then return true end

    -- If none worked, return false
    return false
end

-- Chat notification helper (non-blocking)
local function notify(msg)
    pcall(function()
        if game:GetService("StarterGui"):IsLoaded() then
            game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {
                Text = "[AutoRejoin] " .. tostring(msg);
                Color = Color3.fromRGB(140, 200, 255);
                Font = Enum.Font.SourceSansBold;
                FontSize = Enum.FontSize.Size18;
            })
        end
    end)
end

-- Main loop: queue payload, countdown, teleport, repeat
task.spawn(function()
    while true do
        -- build payload and attempt to queue it
        local payload = buildPayload(loader_url)
        local queued = tryQueueOnTeleport(payload)

        if not queued then
            notify("Warning: queue_on_teleport not detected. Reattach may fail on next join.")
        else
            notify("Reattach payload queued successfully.")
        end

        -- optional countdown
        if COUNTDOWN_SECONDS > 0 then
            for i = COUNTDOWN_SECONDS, 1, -1 do
                notify(("Rejoining in %d..."):format(i))
                task.wait(1)
            end
        else
            task.wait(0.1) -- tiny wait so SetCore chat messages can appear
        end

        -- Teleport to the same place (client-side)
        local success, err = pcall(function()
            TeleportService:Teleport(game.PlaceId, player)
        end)
        if not success then
            notify("Teleport failed: " .. tostring(err))
            -- if teleport failed, don't busy-loop; wait a short bit then try again
            task.wait(10)
        end

        -- Wait full interval before next attempt (this wait only runs if teleport didn't immediately move us)
        -- Note: when teleport succeeds the script environment will typically reset; the queued payload will run there.
        task.wait(REJOIN_INTERVAL)
    end
end)
